.. |GB| replace:: **GeoBatch**
.. _`flwCnfg`:

Flow configuration
==================

GeoBatch is based on flows, where specific *events* trigger a sequence of associated *actions*.

Events are generated by an *Event Generator*, which builds a queue of events controlled by the *Event Dispatcher* (producer-consumer). The Event Dispatcher starts an *Event Consumer* thread which effectively runs *actions* sequentially, as specified in the *flow* file.

Actually GeoBatch is using Xstream so flows are defined as XML files stored into ``GEOBATCH_CONFIG_DIR``. Here is an example of a flow configuration outline:

.. sourcecode:: xml

  <?xml version="1.0" encoding="UTF-8"?>
  <FlowConfiguration>
    <id></id>
    <name></name>
    <description></description>
    
    <corePoolSize>10</corePoolSize>
    <maximumPoolSize>30</maximumPoolSize>
    <keepAliveTime>150</keepAliveTime> <!--seconds-->
    <workQueueSize>100</workQueueSize>
    
	<!-- optional: used to override the default -->
	<overrideConfigDir></overrideConfigDir>
	
	<!-- keep consumer instance into memory map until they are manually removed -->
    <keepConsumers>false</keepConsumers>
    <!-- maximum number of consumer instances -->
    <maxStoredConsumers>6</maxStoredConsumers>

    <EventGeneratorConfiguration>
      <serviceID></serviceID>
    </EventGeneratorConfiguration>

    <EventConsumerConfiguration>
      <!-- keep runtime dir when consumer instance is disposed -->
      <keepRuntimeDir>[true|false]<keepRuntimeDir>
	  
      <ACTION_1_Configuration>
			<!-- optional: used to override the default -->
			<overrideConfigDir></overrideConfigDir>
      </ACTION_1_Configuration>
      <ACTION_N_Configuration>
      </ACTION_N_Configuration>
    </EventConsumerConfiguration>

    <ListenerConfigurations>
    </ListenerConfigurations>	
  </FlowConfiguration>


Identifiers
...........

The ``<FlowConfiguration>`` represents an *identifiable* resource, so you have to specify an ``id``, a ``name`` and a ``description``:

.. sourcecode:: xml

    <id>FLOW_ID</id>
    <name>FLOW_NAME</name>
    <description>FLOW_DESCRIPTION</description>

The ``id`` has to be the same as the flow configuration file name. For example, a file called ``example_flow.xml`` will contain:

.. sourcecode:: xml

    <id>example_flow</id>

Configuration directory
.........................

Can be relative to the ``GEOBATCH_CONFIG_DIR``, or an absolute path and accepted into consumer and action configuration nodes:

.. sourcecode:: xml

    <!-- optional: used to override the default -->
	<overrideConfigDir>override_dir</overrideConfigDir>

If not specified, it will be assumed to be ``GEOBATCH_CONFIG_DIR/FLOW_ID`` for consumer and ``GEOBATCH_CONFIG_DIR/FLOW_ID/ACTION_ID`` for actions.


Thread pool
...........

Each Flow configuration is handled by a Flow Manager instance which creates a new ``ThreadPoolExecutor`` with the given initial parameters and default thread factory and handler. It may be more convenient to use one of the Executor's factory methods instead of this general purpose constructor.

Elements:

* ``<corePoolSize>``: The number of threads to keep in the pool, even if they are idle.
* ``<maximumPoolSize>``: The maximum number of threads to allow in the pool.
* ``<keepAliveTime>``: When the number of threads is greater than the core pool size, this is the maximum time (in seconds) that the exceeding threads will live in idle state.
* ``<workQueueSize>``: the size of the queue to use for holding tasks before they are executed. This queue will hold only the Runnable tasks submitted by the execute method. 

.. sourcecode:: xml

  <?xml version="1.0" encoding="UTF-8"?>
  <FlowConfiguration>
    <id>FLOW_NAME</id>
    <name>NAME</name>
    <description>DESCRIPTION</description>
    <autorun>true</autorun>

    <corePoolSize>10</corePoolSize>
    <maximumPoolSize>30</maximumPoolSize>
    <keepAliveTime>150</keepAliveTime> <!--seconds-->
    <workQueueSize>100</workQueueSize>
	
	<-- maximum numbers of stored consumers executions (as shown into the GUI) -->
    <!-- DEFAULT_maxStoredConsumers = 100 -->
    <maxStoredConsumers>100</maxStoredConsumers>

	<-- keep consumer into the store until a dispose is called (via GUI or JMX) -->
	<!-- default is set to false which means that when maxStoredConsumer is reached if a new consumer is requested (f.e.: generating a new event) the oldest one will be removed -->
    <keepConsumers>false</keepConsumers>
	
	<-- keep temporary directory into the store when a dispose is called (automatically by the flow manager or via GUI or JMX) -->
	<!-- default is set to false which means that when maxStoredConsumer is reached if a new consumer is requested (f.e.: generating a new event) the oldest one will be removed -->
	<keepTempDir>false</keepTempDir>
	
  </FlowConfiguration>


Consumer configuration
.......................

This is an *identifiable* component so you have to specify ``id``, ``name`` and ``description``. Plus:

* ``<listenerId>``: List of listeners used by this consumer, specified by ID (see `listener configuration`_ for details).
* ``<preserveInput>``: ``true`` to preserve input files. Defaults to ``false``. If this flag is set to ``true`` the consumer will work directly on the input data. Please be careful with this option since the event generator can trigger events on file modification.
* ``<performBackup>``: ``true`` to create a directory called ``backup`` under the working directory. Defaults to ``false``.

* **Actions**: A list of actions. Element names depend on the type of action to be performed.

.. sourcecode:: xml

  <EventConsumerConfiguration>
    
    <listenerId>ConsumerLogger0</listenerId>
    <listenerId>ConsumerCumulator0</listenerId>

    <preserveInput>false</preserveInput>
    <performBackup>false</performBackup>
    
    <ACTION_1_Configuration>
    </ACTION_1_Configuration>
    
    <ACTION_N_Configuration>
    </ACTION_N_Configuration>
	
  </EventConsumerConfiguration>

Event generator
...............

Actually, the only supported event generator is the *File System Event Generator*.

.. sourcecode:: xml

  <EventGeneratorConfiguration>
    <serviceID>fsEventGeneratorService</serviceID>
    
  </EventGeneratorConfiguration>


Filesystem Event Generator
^^^^^^^^^^^^^^^^^^^^^^^^^^

Again, it is an *identifiable* object, with an id, a name and a description. Other elements:

* ``<interval>``: Polling interval (in milliseconds). Positive long integer (ranging 1 to 2e63-1). Defaults to 5000.

Example:

.. sourcecode:: xml

  <EventGeneratorConfiguration>
    <serviceID>fsEventGeneratorService</serviceID>
    <wildCard>*.*</wildCard>
    <watchDirectory>geotiff/in</watchDirectory>
    <osType>OS_UNDEFINED</osType>
    <eventType>FILE_ADDED</eventType>
    <interval>10000</interval>
  </EventGeneratorConfiguration>


Listener configuration
......................

Each listener configuration is referred from other places using the ``<listenerId>`` element, whose value corresponds to the listener's ``<id>`` value.

* ``<id>``: Listener's identifier.
* ``<serviceID>``: Represents an alias id for the class to use and (actually) can be:

  * *cumulatingListenerService*: It is a service that is used to instantiate ProgressCumulatingListener (class), which is used by graphical interface to send status messages to the graphical interface, and must be configured at the level of consumer.
  * *statusListenerService*: It is a service that is used to instantiate ProgressStatusListener (class). Used to define lists that graphical interface uses to monitor the status of individual actions. Should be used only in the configuration of an action.
  * *loggingListenerService*: It is a service that is used to instantiate ProgressLoggingListener (class), is used to log events in progress. For example: 

    1. *Consumer started*
    2. *Action started*
    3. *Action concluded*

.. sourcecode:: xml

  <ListenerConfigurations>
    <CumulatingProgressListener>
      <serviceID>cumulatingListenerService</serviceID>
      <id>ConsumerLogger0</id>
    </CumulatingProgressListener>

    <StatusProgressListener>
      <serviceID>statusListenerService</serviceID>
      <id>ActionListener0</id>
    </StatusProgressListener>		

    <LoggingProgressListener>
      <serviceID>loggingListenerService</serviceID>
      <id>ActionListener1</id>
      <loggerName>ActionListener1</loggerName>
    </LoggingProgressListener>

    <LoggingProgressListener>
      <serviceID>loggingListenerService</serviceID>
      <id>ConsumerLogger0</id>
      <loggerName>ConsumerLogger0</loggerName>
    </LoggingProgressListener>
  </ListenerConfigurations>
  
Actions' Temp directories 
.............................

Each Action instance needs to use a separate subdirectory under the base temp dir. The |GB| Engine will manage its creation, as explained below. In case an Action is instantiated manually and not through |GB| Engine, you will need to manage the subdirectory creation manually.

Subdirectory creation under ``GEOBATCH_CONFIG_DIR`` is automatically managed by |GB|, according to this pattern:

* Each flow wil have a separate temp dir for all of its running instances (the ``flowTempDir``):

  * By default this directory is called like the flow ID and is located under ``GEOBATCH_TEMP_DIR``.
  * Can be overridden in the FlowConfiguration, either as an absolute dir or as a relative one. In the latter case, it will be located under ``GEOBATCH_TEMP_DIR``.

* Every running instance of a flow has its own temp dir (the ``flowInstanceTempDir``):

  * By default, the name of this dir is built using the timestamp of its instantiation, and is placed inside its related ``flowTempDir``.

* Finally, every Action inside a running flow instance will have its own temp dir:

  * By default, the dir name is built using the Action ordinal position in the flow, and its ID (e.g. ``1_tiffRetile``), and is placed inside its related ``flowInstanceTempDir``.
